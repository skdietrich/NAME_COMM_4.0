<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced NAMECOMMS v2.0 - WORKING VERSION</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #00ff00;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #00ff00;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .subtitle {
            text-align: center;
            font-size: 0.9em;
            color: #00aaaa;
            margin-bottom: 10px;
        }
        
        .status {
            text-align: center;
            color: #ffaa00;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        .panel h2 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #00ffff;
            border-bottom: 1px solid #00ff00;
            padding-bottom: 5px;
        }
        
        button {
            background: linear-gradient(135deg, #00aa00 0%, #00ff00 100%);
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            margin: 5px;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            width: 100%;
        }
        
        button:hover {
            background: linear-gradient(135deg, #00ff00 0%, #00aa00 100%);
            box-shadow: 0 0 15px #00ff00;
            transform: scale(1.02);
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        .big-button {
            font-size: 1.5em;
            padding: 20px;
            margin: 20px 0;
        }
        
        label {
            display: block;
            margin: 10px 0 5px 0;
            color: #00aaaa;
            font-size: 0.9em;
        }
        
        input, select {
            width: 100%;
            padding: 10px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            color: #00ff00;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin-bottom: 10px;
        }
        
        input[type="range"] {
            cursor: pointer;
        }
        
        .output-display {
            background: rgba(0, 50, 100, 0.3);
            border: 2px solid #00aaaa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            min-height: 300px;
            max-height: 600px;
            overflow-y: auto;
        }
        
        .output-item {
            background: rgba(0, 20, 40, 0.6);
            border-left: 3px solid #00ff00;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
        }
        
        .output-text {
            font-size: 1.2em;
            line-height: 1.8;
            margin: 10px 0;
            color: #ffffff;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .metric {
            background: rgba(0, 100, 0, 0.2);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        .metric-label {
            font-size: 0.8em;
            color: #00aaaa;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-size: 1.3em;
            color: #00ffff;
            font-weight: bold;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid #00ff00;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
            display: none;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00aa00 0%, #00ff00 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
        }
        
        .log {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff0033;
            border-radius: 5px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.85em;
        }
        
        .log-entry {
            margin: 3px 0;
            padding: 3px;
        }
        
        .log-info { color: #00aaaa; }
        .log-success { color: #00ff00; }
        .log-warning { color: #ffaa00; }
        .log-error { color: #ff0000; }
        
        .value-display {
            display: inline-block;
            background: rgba(0, 255, 0, 0.2);
            padding: 3px 10px;
            border-radius: 3px;
            margin-left: 10px;
            color: #00ffff;
        }
        
        .footer {
            margin-top: 40px;
            padding: 25px;
            background: rgba(0, 50, 100, 0.3);
            border: 2px solid #00aaaa;
            border-radius: 10px;
            font-size: 0.9em;
            line-height: 1.8;
        }
        
        .footer h3 {
            color: #00ffff;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚öõ ADVANCED NAMECOMMS v2.0 ‚öõ</h1>
        <div class="subtitle">Neural Anomaly Manifold Entropy Communication Orchestration & Markov-Monte Carlo Simulation</div>
        <div class="subtitle" style="font-size: 1em; color: #ffaa00; margin-bottom: 20px;">
            A GPU-Accelerated Random Signal Analysis & Pattern Recognition Research Tool
        </div>
        <div class="status" id="status">‚è≥ Initializing system...</div>
        
        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill">0%</div>
        </div>
        
        <div class="grid">
            <!-- GENERATION PANEL -->
            <div class="panel">
                <h2>üéØ Generation Controls</h2>
                
                <button class="big-button" onclick="generate()">‚ö° GENERATE TEXT</button>
                
                <label>Output Length: <span class="value-display" id="lengthValue">50</span></label>
                <input type="range" id="length" min="10" max="500" value="50" oninput="updateValue('length', 'lengthValue')">
                
                <label>Phoneme Complexity:</label>
                <select id="complexity">
                    <option value="basic">Basic (Simple patterns)</option>
                    <option value="standard" selected>Standard (Normal complexity)</option>
                    <option value="complex">Complex (Advanced patterns)</option>
                    <option value="extreme">Extreme (Maximum complexity)</option>
                </select>
                
                <label>Temperature: <span class="value-display" id="tempValue">1.0</span></label>
                <input type="range" id="temperature" min="0.1" max="2.0" step="0.1" value="1.0" oninput="updateValue('temperature', 'tempValue')">
                
                <label>Markov Order: <span class="value-display" id="markovValue">3</span></label>
                <input type="range" id="markovOrder" min="1" max="5" value="3" oninput="updateValue('markovOrder', 'markovValue')">
            </div>
            
            <!-- ENTROPY SOURCES -->
            <div class="panel">
                <h2>üé≤ Entropy Sources</h2>
                
                <label>Monte Carlo Weight: <span class="value-display" id="mcWeightValue">0.40</span></label>
                <input type="range" id="mcWeight" min="0" max="1" step="0.05" value="0.40" oninput="updateValue('mcWeight', 'mcWeightValue')">
                
                <label>Crypto Random Weight: <span class="value-display" id="cryptoWeightValue">0.30</span></label>
                <input type="range" id="cryptoWeight" min="0" max="1" step="0.05" value="0.30" oninput="updateValue('cryptoWeight', 'cryptoWeightValue')">
                
                <label>Atmospheric Weight: <span class="value-display" id="atmWeightValue">0.30</span></label>
                <input type="range" id="atmWeight" min="0" max="1" step="0.05" value="0.30" oninput="updateValue('atmWeight', 'atmWeightValue')">
                
                <label>MC Iterations (√ó1000): <span class="value-display" id="mcIterValue">100</span></label>
                <input type="range" id="mcIterations" min="10" max="1000" step="10" value="100" oninput="updateValue('mcIterations', 'mcIterValue')">
                
                <button onclick="normalizeWeights()">‚öñ Normalize Weights</button>
            </div>
            
            <!-- METRICS -->
            <div class="panel">
                <h2>üìä Statistical Metrics</h2>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Shannon Entropy</div>
                        <div class="metric-value" id="shannonEntropy">0.0000</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Complexity</div>
                        <div class="metric-value" id="complexity">0.0000</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Chi-Square</div>
                        <div class="metric-value" id="chiSquare">0.00</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Autocorrelation</div>
                        <div class="metric-value" id="autocorrelation">0.0000</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Patterns</div>
                        <div class="metric-value" id="patterns">0</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Generations</div>
                        <div class="metric-value" id="genCount">0</div>
                    </div>
                </div>
            </div>
            
            <!-- SYSTEM LOG -->
            <div class="panel">
                <h2>üìù System Log</h2>
                <div class="log" id="log"></div>
                <button onclick="clearLog()">Clear Log</button>
            </div>
        </div>
        
        <!-- OUTPUT DISPLAY -->
        <div class="panel">
            <h2>üì§ Generated Output</h2>
            <div class="output-display" id="output"></div>
        </div>
        
        <!-- PRIVACY FOOTER -->
        <div class="footer">
            <h3>üîí Privacy & Ethics Statement</h3>
            <p><strong>No Data Transmission:</strong> All processing occurs locally in your browser. No personal data, generated text, or entropy data is transmitted to external servers.</p>
            <p><strong>Local Processing:</strong> Everything runs on your computer. No internet connection required after loading.</p>
            <p><strong>Research Ethics:</strong> This tool generates pseudorandom text for research and educational purposes. Any perceived "messages" result from statistical randomness and human pattern recognition (pareidolia), not supernatural communication.</p>
            <p><strong>Compliance:</strong> Designed for IRB research protocols and data privacy regulations.</p>
        </div>
    </div>

    <script>
        // ============================================================================
        // CORE APPLICATION CLASS
        // ============================================================================
        
        class NAMECOMMS {
            constructor() {
                this.entropyPool = new Uint8Array(1024);
                this.generationHistory = [];
                this.markovChains = {};
                this.phonemePatterns = this.initPhonemePatterns();
                this.genCount = 0;
                
                this.init();
            }
            
            init() {
                this.log('Initializing NAMECOMMS v2.0...', 'info');
                
                // Initialize entropy pool
                crypto.getRandomValues(this.entropyPool);
                
                this.log('‚úì System initialized successfully!', 'success');
                this.log('‚úì Entropy pool ready (' + this.entropyPool.length + ' bytes)', 'success');
                this.log('‚úì Phoneme patterns loaded', 'success');
                
                document.getElementById('status').textContent = '‚úÖ System Ready - Click GENERATE TEXT';
                document.getElementById('status').style.color = '#00ff00';
            }
            
            // ============================================================================
            // PHONEME PATTERNS
            // ============================================================================
            
            initPhonemePatterns() {
                return {
                    basic: {
                        consonants: ['b', 'k', 'd', 'f', 'g', 'h', 'l', 'm', 'n', 'p', 'r', 's', 't', 'v', 'w', 'z'],
                        vowels: ['a', 'e', 'i', 'o', 'u'],
                        patterns: ['CV', 'VC', 'CVC']
                    },
                    standard: {
                        consonants: ['b', 'k', 'd', 'f', 'g', 'h', 'j', 'l', 'm', 'n', 'p', 'r', 's', 't', 'v', 'w', 'y', 'z', 'ch', 'sh', 'th'],
                        vowels: ['a', 'e', 'i', 'o', 'u', 'ae', 'ai', 'au', 'ea', 'ee', 'ie', 'oo', 'ou'],
                        patterns: ['CVC', 'CV', 'VC', 'V', 'CVCC', 'CCVC']
                    },
                    complex: {
                        consonants: ['b', 'k', 'd', 'f', 'g', 'h', 'j', 'l', 'm', 'n', 'p', 'r', 's', 't', 'v', 'w', 'y', 'z', 'ch', 'sh', 'th', 'ph', 'gh', 'wh'],
                        vowels: ['a', 'e', 'i', 'o', 'u', 'ae', 'ai', 'au', 'ea', 'ee', 'ie', 'oo', 'ou', 'oi', 'oy', 'ui'],
                        clusters: ['bl', 'br', 'cl', 'cr', 'dr', 'fl', 'fr', 'gl', 'gr', 'pl', 'pr', 'sk', 'sl', 'sm', 'sn', 'sp', 'st', 'sw', 'tr'],
                        patterns: ['CCVCC', 'CVC', 'CCVC', 'CVCC', 'CV', 'CCV', 'CCCVC']
                    },
                    extreme: {
                        consonants: ['b', 'k', 'd', 'f', 'g', 'h', 'j', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z', 'ch', 'sh', 'th', 'ph', 'gh', 'wh', 'kh', 'ng'],
                        vowels: ['a', 'e', 'i', 'o', 'u', 'ae', 'ai', 'au', 'ea', 'ee', 'ie', 'oo', 'ou', 'oi', 'oy', 'ui', 'ue', 'eu', 'eo', 'ya', 'ye'],
                        clusters: ['bl', 'br', 'cl', 'cr', 'dr', 'fl', 'fr', 'gl', 'gr', 'pl', 'pr', 'sk', 'sl', 'sm', 'sn', 'sp', 'st', 'sw', 'tr', 'scr', 'spl', 'spr', 'str', 'shr', 'thr'],
                        patterns: ['CCCVCC', 'CCVCC', 'CCCVC', 'CCVCC', 'CVC', 'CCVC', 'CVCC', 'CV', 'CCV', 'VCC', 'CVCCC']
                    }
                };
            }
            
            // ============================================================================
            // ENTROPY FUNCTIONS
            // ============================================================================
            
            getEntropy() {
                const index = Math.floor(Math.random() * this.entropyPool.length);
                return this.entropyPool[index] / 255.0;
            }
            
            async mixEntropy() {
                try {
                    this.log('Mixing entropy sources...', 'info');
                    
                    const weights = {
                        mc: parseFloat(document.getElementById('mcWeight').value),
                        crypto: parseFloat(document.getElementById('cryptoWeight').value),
                        atm: parseFloat(document.getElementById('atmWeight').value)
                    };
                    
                    // Monte Carlo entropy
                    const mcIterations = parseInt(document.getElementById('mcIterations').value) * 1000;
                    const mcEntropy = this.runMonteCarlo(Math.min(mcIterations, 100000));
                    
                    // Crypto entropy
                    const cryptoEntropy = new Uint8Array(256);
                    crypto.getRandomValues(cryptoEntropy);
                    
                    // Atmospheric entropy (timing, random events)
                    const atmEntropy = this.collectAtmospheric();
                    
                    // Mix with weights
                    for (let i = 0; i < this.entropyPool.length; i++) {
                        const mcVal = mcEntropy[i % mcEntropy.length];
                        const cryptoVal = cryptoEntropy[i % cryptoEntropy.length];
                        const atmVal = atmEntropy[i % atmEntropy.length];
                        
                        this.entropyPool[i] = Math.floor(
                            mcVal * weights.mc +
                            cryptoVal * weights.crypto +
                            atmVal * weights.atm
                        );
                    }
                    
                    this.log('‚úì Entropy mixed successfully', 'success');
                } catch (error) {
                    this.log('Entropy mix error: ' + error.message, 'error');
                    // Fallback to crypto random
                    crypto.getRandomValues(this.entropyPool);
                }
            }
            
            runMonteCarlo(iterations) {
                const result = new Uint8Array(256);
                
                for (let i = 0; i < iterations; i++) {
                    // Enhanced Monte Carlo with better distribution
                    const x = Math.random();
                    const y = Math.random();
                    
                    // Complex probability distribution
                    let value = Math.sin(x * Math.PI * 2) * Math.cos(y * Math.PI);
                    value += Math.sqrt(Math.abs(x - 0.5)) * Math.sign(y - 0.5);
                    value += Math.log(1 + x) * Math.exp(-y);
                    
                    // Normalize to 0-255
                    const normalized = Math.floor(((value + 3) / 6) * 255);
                    result[i % 256] = Math.max(0, Math.min(255, normalized));
                }
                
                return result;
            }
            
            collectAtmospheric() {
                const result = new Uint8Array(256);
                
                // Use various timing and environmental sources
                const now = Date.now();
                const perf = performance.now();
                
                for (let i = 0; i < 256; i++) {
                    // Mix multiple atmospheric sources
                    let value = 0;
                    value += (now >> i) & 0xFF;
                    value += (perf * 1000 >> i) & 0xFF;
                    value += (Math.random() * 255);
                    
                    result[i] = value % 256;
                }
                
                return result;
            }
            
            // ============================================================================
            // TEXT GENERATION
            // ============================================================================
            
            async generate() {
                try {
                    const startTime = performance.now();
                    this.log('üöÄ Starting generation...', 'info');
                    
                    // Show progress
                    this.showProgress(0);
                    
                    // Mix entropy
                    await this.mixEntropy();
                    this.showProgress(30);
                    
                    // Get parameters
                    const length = parseInt(document.getElementById('length').value);
                    const complexity = document.getElementById('complexity').value;
                    const markovOrder = parseInt(document.getElementById('markovOrder').value);
                    
                    // Build Markov chain from history
                    if (this.generationHistory.length > 0) {
                        const combined = this.generationHistory.join(' ');
                        this.markovChains = this.buildMarkovChain(combined, markovOrder);
                        this.log('Markov chain built: ' + Object.keys(this.markovChains).length + ' n-grams', 'info');
                    }
                    this.showProgress(50);
                    
                    // Generate text
                    let output;
                    if (Object.keys(this.markovChains).length > 10 && this.getEntropy() > 0.3) {
                        output = this.generateFromMarkov(length);
                        this.log('Generated using Markov chain', 'info');
                    } else {
                        output = this.generateFromPhonemes(length, complexity);
                        this.log('Generated using phonemes', 'info');
                    }
                    this.showProgress(75);
                    
                    // Post-process
                    output = this.postProcess(output);
                    this.showProgress(90);
                    
                    // Analyze
                    const analysis = this.analyze(output);
                    this.showProgress(100);
                    
                    // Display
                    this.display(output, analysis);
                    
                    // Store in history
                    this.generationHistory.push(output);
                    this.genCount++;
                    document.getElementById('genCount').textContent = this.genCount;
                    
                    const endTime = performance.now();
                    this.log('‚úÖ Generation complete in ' + (endTime - startTime).toFixed(2) + 'ms', 'success');
                    
                    this.hideProgress();
                    
                } catch (error) {
                    this.log('‚ùå Generation error: ' + error.message, 'error');
                    console.error(error);
                    this.hideProgress();
                }
            }
            
            generateFromPhonemes(length, complexity) {
                const phonemes = this.phonemePatterns[complexity];
                let output = '';
                
                while (output.length < length) {
                    // Select random pattern
                    const pattern = phonemes.patterns[Math.floor(this.getEntropy() * phonemes.patterns.length)];
                    let syllable = '';
                    
                    for (let char of pattern) {
                        if (char === 'C') {
                            // Consonant
                            if (phonemes.clusters && this.getEntropy() > 0.75) {
                                syllable += phonemes.clusters[Math.floor(this.getEntropy() * phonemes.clusters.length)];
                            } else {
                                syllable += phonemes.consonants[Math.floor(this.getEntropy() * phonemes.consonants.length)];
                            }
                        } else if (char === 'V') {
                            // Vowel
                            syllable += phonemes.vowels[Math.floor(this.getEntropy() * phonemes.vowels.length)];
                        }
                    }
                    
                    output += syllable;
                    
                    // Add spaces probabilistically
                    if (this.getEntropy() > 0.82 && output.length < length - 10) {
                        output += ' ';
                    }
                }
                
                return output.slice(0, length);
            }
            
            generateFromMarkov(length) {
                const grams = Object.keys(this.markovChains);
                if (grams.length === 0) {
                    return this.generateFromPhonemes(length, 'standard');
                }
                
                // Start with random n-gram
                let current = grams[Math.floor(this.getEntropy() * grams.length)];
                let output = current;
                
                const temperature = parseFloat(document.getElementById('temperature').value);
                
                for (let i = 0; i < length - current.length; i++) {
                    const next = this.markovChains[current];
                    
                    if (!next || next.length === 0) {
                        // Restart with new gram
                        current = grams[Math.floor(this.getEntropy() * grams.length)];
                        output += ' ' + current;
                        continue;
                    }
                    
                    // Temperature-controlled selection
                    let idx;
                    if (temperature > 1.0) {
                        // Higher temp = more random
                        idx = Math.floor(Math.pow(this.getEntropy(), 1/temperature) * next.length);
                    } else {
                        // Lower temp = more predictable
                        idx = Math.floor(Math.pow(this.getEntropy(), temperature) * next.length);
                    }
                    
                    const char = next[idx];
                    output += char;
                    current = current.slice(1) + char;
                }
                
                return output;
            }
            
            buildMarkovChain(text, order) {
                const chain = {};
                
                for (let i = 0; i < text.length - order; i++) {
                    const gram = text.slice(i, i + order);
                    const next = text[i + order];
                    
                    if (!chain[gram]) {
                        chain[gram] = [];
                    }
                    chain[gram].push(next);
                }
                
                return chain;
            }
            
            postProcess(text) {
                // Remove excessive repetition
                text = text.replace(/(.)\1{3,}/g, '$1$1');
                
                // Fix spacing
                text = text.replace(/([a-z])([A-Z])/g, '$1 $2');
                text = text.replace(/\s+/g, ' ');
                
                // Capitalize sentences
                text = text.replace(/(^|[.!?]\s+)([a-z])/g, (m, p1, p2) => p1 + p2.toUpperCase());
                
                // Capitalize first letter
                if (text.length > 0) {
                    text = text[0].toUpperCase() + text.slice(1);
                }
                
                return text.trim();
            }
            
            // ============================================================================
            // ANALYSIS FUNCTIONS
            // ============================================================================
            
            analyze(text) {
                const shannon = this.calcShannonEntropy(text);
                const complexity = this.calcComplexity(text);
                const chiSquare = this.calcChiSquare(text);
                const autocorr = this.calcAutocorrelation(text);
                const patterns = this.detectPatterns(text);
                
                // Update display
                document.getElementById('shannonEntropy').textContent = shannon.toFixed(4);
                document.getElementById('complexity').textContent = complexity.toFixed(4);
                document.getElementById('chiSquare').textContent = chiSquare.toFixed(2);
                document.getElementById('autocorrelation').textContent = autocorr.toFixed(4);
                document.getElementById('patterns').textContent = patterns;
                
                return { shannon, complexity, chiSquare, autocorr, patterns };
            }
            
            calcShannonEntropy(text) {
                const freq = {};
                for (let char of text) {
                    freq[char] = (freq[char] || 0) + 1;
                }
                
                let entropy = 0;
                const len = text.length;
                
                for (let char in freq) {
                    const p = freq[char] / len;
                    entropy -= p * Math.log2(p);
                }
                
                return entropy;
            }
            
            calcComplexity(text) {
                // Estimate Kolmogorov complexity using compression ratio
                const original = new Blob([text]).size;
                const compressed = this.simpleCompress(text).length;
                return compressed / original;
            }
            
            simpleCompress(text) {
                // Simple run-length encoding
                let result = '';
                let count = 1;
                
                for (let i = 1; i < text.length; i++) {
                    if (text[i] === text[i-1]) {
                        count++;
                    } else {
                        result += (count > 1 ? count : '') + text[i-1];
                        count = 1;
                    }
                }
                result += (count > 1 ? count : '') + text[text.length - 1];
                
                return result;
            }
            
            calcChiSquare(text) {
                const observed = {};
                for (let char of text) {
                    observed[char] = (observed[char] || 0) + 1;
                }
                
                const expected = text.length / 26; // Assume 26 letters
                let chiSq = 0;
                
                for (let char in observed) {
                    const diff = observed[char] - expected;
                    chiSq += (diff * diff) / expected;
                }
                
                return chiSq;
            }
            
            calcAutocorrelation(text) {
                if (text.length < 2) return 0;
                
                let sum = 0;
                for (let lag = 1; lag < Math.min(10, text.length); lag++) {
                    let corr = 0;
                    for (let i = 0; i < text.length - lag; i++) {
                        if (text[i] === text[i + lag]) {
                            corr++;
                        }
                    }
                    sum += corr / (text.length - lag);
                }
                
                return sum / Math.min(10, text.length - 1);
            }
            
            detectPatterns(text) {
                const patterns = new Set();
                
                // Look for repeated substrings
                for (let len = 2; len <= Math.min(5, text.length/2); len++) {
                    for (let i = 0; i <= text.length - len; i++) {
                        const substr = text.slice(i, i + len);
                        if (text.indexOf(substr, i + 1) !== -1) {
                            patterns.add(substr);
                        }
                    }
                }
                
                return patterns.size;
            }
            
            // ============================================================================
            // DISPLAY FUNCTIONS
            // ============================================================================
            
            display(text, analysis) {
                const outputDiv = document.getElementById('output');
                const timestamp = new Date().toLocaleTimeString();
                
                const item = document.createElement('div');
                item.className = 'output-item';
                item.innerHTML = `
                    <div style="color: #00aaaa; font-size: 0.9em; margin-bottom: 10px;">
                        [${timestamp}] Generation #${this.genCount + 1} | ${text.length} characters
                    </div>
                    <div class="output-text">${text}</div>
                    <div style="font-size: 0.85em; color: #00aaaa; margin-top: 10px; padding-top: 10px; border-top: 1px solid #00ff0033;">
                        H: ${analysis.shannon.toFixed(3)} | 
                        K: ${analysis.complexity.toFixed(3)} | 
                        œá¬≤: ${analysis.chiSquare.toFixed(1)} | 
                        œÅ: ${analysis.autocorr.toFixed(3)} | 
                        P: ${analysis.patterns}
                    </div>
                `;
                
                outputDiv.insertBefore(item, outputDiv.firstChild);
            }
            
            showProgress(percent) {
                const bar = document.getElementById('progressBar');
                const fill = document.getElementById('progressFill');
                bar.style.display = 'block';
                fill.style.width = percent + '%';
                fill.textContent = percent + '%';
            }
            
            hideProgress() {
                setTimeout(() => {
                    document.getElementById('progressBar').style.display = 'none';
                }, 1000);
            }
            
            log(message, type = 'info') {
                const logDiv = document.getElementById('log');
                const entry = document.createElement('div');
                entry.className = 'log-entry log-' + type;
                entry.textContent = '[' + new Date().toLocaleTimeString() + '] ' + message;
                logDiv.appendChild(entry);
                logDiv.scrollTop = logDiv.scrollHeight;
                
                console.log(message);
            }
        }
        
        // ============================================================================
        // GLOBAL FUNCTIONS
        // ============================================================================
        
        let app;
        
        window.addEventListener('DOMContentLoaded', () => {
            app = new NAMECOMMS();
        });
        
        function generate() {
            if (!app) {
                alert('System not initialized!');
                return;
            }
            app.generate();
        }
        
        function updateValue(inputId, displayId) {
            const value = document.getElementById(inputId).value;
            document.getElementById(displayId).textContent = value;
        }
        
        function normalizeWeights() {
            const mc = parseFloat(document.getElementById('mcWeight').value);
            const crypto = parseFloat(document.getElementById('cryptoWeight').value);
            const atm = parseFloat(document.getElementById('atmWeight').value);
            
            const sum = mc + crypto + atm;
            
            if (sum > 0) {
                document.getElementById('mcWeight').value = (mc / sum).toFixed(2);
                document.getElementById('cryptoWeight').value = (crypto / sum).toFixed(2);
                document.getElementById('atmWeight').value = (atm / sum).toFixed(2);
                
                updateValue('mcWeight', 'mcWeightValue');
                updateValue('cryptoWeight', 'cryptoWeightValue');
                updateValue('atmWeight', 'atmWeightValue');
                
                app.log('Weights normalized', 'success');
            }
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
    </script>
</body>
</html>
